(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{382:function(t,n,e){"use strict";e.r(n);var s=e(45),v=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"选择排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[t._v("#")]),t._v(" 选择排序")]),t._v(" "),e("p",[t._v("选择排序的核心思想是，首先找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中\n找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。因为它在不断地选择剩余元素之中的最小者，所以称这种方法叫做选择排序。")]),t._v(" "),e("p",[t._v("选择排序的内循环只是在比较当前元素与目前已知的最小元素（以及将当前\n索引加 1 和检查是否代码越界），这已经简单到了极点。交换元素的代码写在内循环之外，每次交")]),t._v(" "),e("p",[t._v("换都能排定一个元素，因此交换的总次数是 N。所以算法的时间效率取决于比较的次数。")]),t._v(" "),e("p",[t._v("总的来说，选择排序是一种很容易理解和实现的简单排序算法，它有两个很鲜明的特点。")]),t._v(" "),e("p",[e("code",[t._v("运行时间和输入无关")]),t._v("。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。\n这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶地发现，一个已经有序的数组或\n是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！我们将会看到，其\n他算法会更善于利用输入的初始状态。")]),t._v(" "),e("p",[e("code",[t._v("数据移动是最少的")]),t._v("。每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换——交\n换次数和数组的大小是线性关系。我们将研究的其他任何算法都不具备这个特征（大部分的增长数\n量级都是线性对数或是平方级别）。")])])}),[],!1,null,null,null);n.default=v.exports}}]);