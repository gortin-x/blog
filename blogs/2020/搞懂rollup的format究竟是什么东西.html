<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>搞懂rollup的format究竟是什么东西 | 苏恩的小站</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="suen's blog">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0b1ac558.css" as="style"><link rel="preload" href="/blog/assets/js/app.9be37e0f.js" as="script"><link rel="preload" href="/blog/assets/js/2.475e6591.js" as="script"><link rel="preload" href="/blog/assets/js/19.ff66857f.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.b500cadf.js"><link rel="prefetch" href="/blog/assets/js/11.656f7513.js"><link rel="prefetch" href="/blog/assets/js/12.8831af61.js"><link rel="prefetch" href="/blog/assets/js/13.32f4eaa7.js"><link rel="prefetch" href="/blog/assets/js/14.30cc69ed.js"><link rel="prefetch" href="/blog/assets/js/15.4a9aeb13.js"><link rel="prefetch" href="/blog/assets/js/16.99c5af55.js"><link rel="prefetch" href="/blog/assets/js/17.7b96355a.js"><link rel="prefetch" href="/blog/assets/js/18.95f24fac.js"><link rel="prefetch" href="/blog/assets/js/20.91d467dd.js"><link rel="prefetch" href="/blog/assets/js/21.760d1af8.js"><link rel="prefetch" href="/blog/assets/js/22.93576086.js"><link rel="prefetch" href="/blog/assets/js/23.3a2d2837.js"><link rel="prefetch" href="/blog/assets/js/24.59bc914b.js"><link rel="prefetch" href="/blog/assets/js/25.adca640d.js"><link rel="prefetch" href="/blog/assets/js/26.c9e93132.js"><link rel="prefetch" href="/blog/assets/js/27.15a7dba2.js"><link rel="prefetch" href="/blog/assets/js/28.a791ff81.js"><link rel="prefetch" href="/blog/assets/js/29.4ad03ea1.js"><link rel="prefetch" href="/blog/assets/js/3.5a8a6ffd.js"><link rel="prefetch" href="/blog/assets/js/30.2bd7f5fe.js"><link rel="prefetch" href="/blog/assets/js/31.7eaaec3d.js"><link rel="prefetch" href="/blog/assets/js/32.8fcd0b1a.js"><link rel="prefetch" href="/blog/assets/js/33.2b689024.js"><link rel="prefetch" href="/blog/assets/js/34.b2ba59d8.js"><link rel="prefetch" href="/blog/assets/js/4.49b2ac44.js"><link rel="prefetch" href="/blog/assets/js/5.3d3a9bd3.js"><link rel="prefetch" href="/blog/assets/js/6.059c934a.js"><link rel="prefetch" href="/blog/assets/js/7.144ac537.js"><link rel="prefetch" href="/blog/assets/js/8.8fea738e.js"><link rel="prefetch" href="/blog/assets/js/9.c0b37a2e.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0b1ac558.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">苏恩的小站</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/archive/" class="nav-link">
  文章
</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/blog/code/" class="nav-link">
  代码片段
</a></div><div class="nav-item"><a href="/blog/issue/" class="nav-link">
  问题汇总
</a></div><div class="nav-item"><a href="/blog/tool/" class="nav-link">
  常用工具
</a></div><div class="nav-item"><a href="/blog/about/" class="nav-link">
  关于
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/archive/" class="nav-link">
  文章
</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/blog/code/" class="nav-link">
  代码片段
</a></div><div class="nav-item"><a href="/blog/issue/" class="nav-link">
  问题汇总
</a></div><div class="nav-item"><a href="/blog/tool/" class="nav-link">
  常用工具
</a></div><div class="nav-item"><a href="/blog/about/" class="nav-link">
  关于
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/archive/" class="sidebar-link">文章</a></li><li><a href="/blog/algorithm/" class="sidebar-link">算法</a></li><li><a href="/blog/code/" class="sidebar-link">代码片段</a></li><li><a href="/blog/issue/" class="sidebar-link">问题汇总</a></li><li><a href="/blog/tool/" class="sidebar-link">常用工具</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="搞懂rollup的format究竟是什么东西"><a href="#搞懂rollup的format究竟是什么东西" class="header-anchor">#</a> 搞懂rollup的format究竟是什么东西</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>在使用rollup的过程中，我们经常可以看到format格式字段，通过配置这个字段我们可以选择性将文件打包成各种不同的形式，那么这个字段究竟对我们的代码做了哪些事呢？为什么要做这些事呢？</p> <h2 id="format使用"><a href="#format使用" class="header-anchor">#</a> format使用</h2> <p>我们先来看下rollup官方对format不同值的解释；</p> <ul><li>cjs – CommonJS，适用于 Node 和 Browserify/Webpack</li> <li>amd – 异步模块定义，用于像RequireJS这样的模块加载器</li> <li>umd – 通用模块定义，以amd，cjs 和 iife 为一体</li> <li>esm – 将软件包保存为 ES 模块文件，在现代浏览器中可以通过 <code>&lt;script type=module&gt;</code> 标签引入</li> <li>iife – 一个自动执行的功能，适合作为<code>&lt;script&gt;</code>标签。（如果要为应用程序创建一个捆绑包，您可能想要使用它，因为它会使文件大小变小。）</li> <li>system - SystemJS 加载器格式</li></ul> <h2 id="commonjs"><a href="#commonjs" class="header-anchor">#</a> CommonJS</h2> <p>CommonJS以服务器端为目标执行环境。</p> <p>CommonJS 模块定义需要使用 require()指定依赖，而使用 exports 对象定义自己的公共 API。</p> <p>下面是一个 CommonJS 模块定义的示例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> moduleB <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./moduleB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    stuff<span class="token operator">:</span> moduleB<span class="token punctuation">.</span><span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果想在浏览器中使用 CommonJS 模块，就需要与其非原生的模块语法之间构筑“桥梁”。常见的解决方案是提前把模块文件打包好，把全局属性转换为原生 JavaScript 结构，将模块代码封装在函数闭包中，最终只提供一个文件。</p> <h2 id="amd"><a href="#amd" class="header-anchor">#</a> AMD</h2> <p>AMD即异步模块定义（Asynchronous Module Definition）以浏览器为目标执行环境。</p> <p>AMD 模块实现的核心是用函数包装模块定义。这样可以防止声明全局变量，并允许加载器库控制何时加载模块。包装函数也便于模块代码的移植，因为包装函数内部的所有模块代码使用的都是原生JavaScript 结构。包装模块的函数是全局 define 的参数，它是由 AMD 加载器库的实现定义的。</p> <p>AMD 模块可以使用字符串标识符指定自己的依赖，而 AMD 加载器会在所有依赖模块加载完毕后立即调用模块工厂函数。与 CommonJS 不同，AMD 支持可选地为模块指定字符串标识符。</p> <p>下面是一个 AMD 模块定义的示例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// ID 为'moduleA'的模块定义。moduleA 依赖 moduleB，</span>
<span class="token comment">// moduleB 会异步加载</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'moduleA'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'moduleB'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">moduleB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        stuff<span class="token operator">:</span> moduleB<span class="token punctuation">.</span><span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="umd"><a href="#umd" class="header-anchor">#</a> UMD</h2> <p>UMD即通用模块定义（Universal Module Definition），是为了统一 CommonJS 和 AMD 生态系统而应运而生的。UMD可用于创建这两个系统都可以使用的模块代码。</p> <p>本质上，UMD 定义的模块会在启动时检测要使用哪个模块系统，然后进行适当配置，并把所有逻辑包装在一个立即调用的函数表达式（IIFE）中。虽然这种组合并不完美，但在很多场景下足以实现两个生态的共存。</p> <p>下面是只包含一个依赖的 UMD 模块定义的示例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> factory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span>amd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// AMD。注册为匿名模块</span>
        <span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'moduleB'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> module <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Node。不支持严格 CommonJS</span>
        <span class="token comment">// 但可以在 Node 这样支持 module.exports 的</span>
        <span class="token comment">// 类 CommonJS 环境下使用</span>
        module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">' moduleB '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 浏览器全局上下文（root 是 window）</span>
        root<span class="token punctuation">.</span>returnExports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span> moduleB<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">moduleB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 以某种方式使用 moduleB</span>
    <span class="token comment">// 将返回值作为模块的导出</span>
    <span class="token comment">// 这个例子返回了一个对象</span>
    <span class="token comment">// 但是模块也可以返回函数作为导出值</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="esm"><a href="#esm" class="header-anchor">#</a> esm</h2> <p>esm是指ES6 module，是从 ES6 开始 JavaScript 引入的模块规范。这个规范全方位简化了之前出现的模块加载器，原生浏览器支持意味着加载器及其他预处理都不再必要。从很多方面看，ES6 模块系统是集 AMD 和 CommonJS之大成者。</p> <h3 id="模块标签及定义"><a href="#模块标签及定义" class="header-anchor">#</a> 模块标签及定义</h3> <p>带有 type=&quot;module&quot;属性的<code>&lt;script&gt;</code>标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。</p> <p>模块可以嵌入在网页中，也可以作为外部文件引入：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span><span class="token operator">&gt;</span>
 <span class="token comment">// 模块代码</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;path/to/myModule.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>与传统脚本不同，所有模块都会像<code>&lt;script defer&gt;加载的脚本一样按顺序执行。解析到&lt;script type=&quot;module&quot;&gt;</code>标签后会立即下载模块文件，但执行会延迟到文档解析完成。无论对嵌入的模块代码，
还是引入的外部模块文件，都是这样。<code>&lt;script type=&quot;module&quot;&gt;</code>在页面中出现的顺序就是它们执行
的顺序。与<code>&lt;script defer&gt;</code>一样，修改模块标签的位置，无论是在<code>&lt;head&gt;</code>还是在<code>&lt;body&gt;</code>中，只会影响文件什么时候加载，而不会影响模块什么时候加载。</p> <h3 id="模块行为"><a href="#模块行为" class="header-anchor">#</a> 模块行为</h3> <p>ECMAScript 6 模块借用了 CommonJS 和 AMD 的很多优秀特性。下面简单列举一些。</p> <ul><li>模块代码只在加载后执行。</li> <li>模块只能加载一次。</li> <li>模块是单例。</li> <li>模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。</li> <li>模块可以请求加载其他模块。</li> <li>支持循环依赖。</li></ul> <p>ES6 模块系统也增加了一些新行为。</p> <ul><li>ES6 模块默认在严格模式下执行。</li> <li>ES6 模块不共享全局命名空间。</li> <li>模块顶级 this 的值是 undefined（常规脚本中是 window）。</li> <li>模块中的 var 声明不会添加到 window 对象。</li> <li>ES6 模块是异步加载和执行的。</li></ul> <h3 id="模块导出"><a href="#模块导出" class="header-anchor">#</a> 模块导出</h3> <p>ES6 模块的公共导出系统与 CommonJS 非常相似。控制模块的哪些部分对外部可见的是 export 关
键字。ES6 模块支持两种导出：命名导出和默认导出。</p> <ul><li>命名导出</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 行内命名导出</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>

<span class="token comment">// 变量声明跟导出可以不在一行</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token comment">// 导出时也可以提供别名</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> foo <span class="token keyword">as</span> myFoo <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 对导出声明分组</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token string">'baz'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token keyword">as</span> myBar<span class="token punctuation">,</span> baz <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>默认导出
默认导出使用 default 关键字将一个值声明为默认导出，每个模块只能有一个默认导出。重复的默认导出会导致 SyntaxError。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> foo<span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>另外，ES6 模块系统会识别作为别名提供的 default 关键字。此时，虽然对应的值是使用命名语
法导出的，实际上则会成为默认导出：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
<span class="token comment">// 等同于 export default foo;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> foo <span class="token keyword">as</span> <span class="token keyword">default</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="模块导入"><a href="#模块导入" class="header-anchor">#</a> 模块导入</h3> <p>模块可以通过使用 import 关键字使用其他模块导出的值。与 export 类似，import 必须出现在
模块的顶级。</p> <p>命名导出和默认导出的区别也反映在它们的导入上。命名导出可以使用*批量获取并赋值给保存导出集合的别名，而无须列出每个标识符：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> bar <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> baz <span class="token operator">=</span> <span class="token string">'baz'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar<span class="token punctuation">,</span> baz <span class="token punctuation">}</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Foo <span class="token keyword">from</span> <span class="token string">'./foo.js'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bar</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// baz</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>要指名导入，需要把标识符放在 import 子句中。使用 import 子句可以为导入的值指定别名：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar<span class="token punctuation">,</span> baz <span class="token keyword">as</span> myBaz <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./foo.js'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bar</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myBaz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// baz </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>默认导出就好像整个模块就是导出的值一样。可以使用 default 关键字并提供别名来导入。也可以不使用大括号，此时指定的标识符就是默认导出的别名：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 等效</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./foo.js'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">'./foo.js'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="模块转移导出"><a href="#模块转移导出" class="header-anchor">#</a> 模块转移导出</h3> <p>模块导入的值可以直接通过管道转移到导出。此时，也可以将默认导出转换为命名导出，或者相反。如果想把一个模块的所有命名导出集中在一块，可以像下面这样在 bar.js 中使用*导出：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">'./foo.js'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样，foo.js 中的所有命名导出都会出现在导入 bar.js 的模块中。如果 foo.js 有默认导出，则该语法会忽略它。使用此语法也要注意导出名称是否冲突。如果 foo.js 导出 baz，bar.js 也导出 baz，则最终导出的是 bar.js 中的值。这个“重写”是静默发生的：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// foo.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token string">'origin:foo'</span><span class="token punctuation">;</span>

<span class="token comment">// bar.js</span>
<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">'./foo.js'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token string">'origin:bar'</span><span class="token punctuation">;</span>

<span class="token comment">// main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> baz <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./bar.js'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// origin:bar</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>此外也可以明确列出要从外部模块转移本地导出的值。该语法支持使用别名：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token keyword">as</span> myBar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./foo.js'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>类似地，外部模块的默认导出可以重用为当前模块的默认导出：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./foo.js'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样不会复制导出的值，只是把导入的引用传给了原始模块。在原始模块中，导入的值仍然是可用
的，与修改导入相关的限制也适用于再次导出的导入。</p> <p>在重新导出时，还可以在导入模块修改命名或默认导出的角色。比如，可以像下面这样将命名导出
指定为默认导出：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> foo <span class="token keyword">as</span> <span class="token keyword">default</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./foo.js'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="iife"><a href="#iife" class="header-anchor">#</a> iife</h2> <p>iife即立即执行函数（ Immediately Invoked Function Expression ）</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// ...dosomething</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="system"><a href="#system" class="header-anchor">#</a> system</h2> <p>system是SystemJs为浏览器中的ES模块启用向后兼容工作流和可配置的模块加载程序，让用户可以在浏览器中使用上述说的几种任意的模块化方式。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>模块模式是管理复杂性的永恒工具。开发者可以通过它创建逻辑彼此独立的代码段，在这些代码段之间声明依赖，并将它们连接在一起。此外，这种模式也是经证明能够优雅扩展到任意复杂度且跨平台的方案。</p> <p>多年以来，CommonJS 和 AMD 这两个分别针对服务器端环境和受延迟限制的客户端环境的模块系统长期分裂。两个系统都获得了爆炸性增强，但为它们编写的代码则在很多方面不一致，经常也会带有冗余的样板代码。而且，这两个系统都没有在浏览器中实现。缺乏兼容导致出现了相关工具，从而让在浏览器中实现模块模式成为可能。</p> <p>ECMAScript 6 规范重新定义了浏览器模块，集之前两个系统之长于一身，并通过更简单的声明性语法暴露出来。浏览器对原生模块的支持越来越好，但也提供了稳健的工具以实现从不支持到支持 ES6模块的过渡。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.9be37e0f.js" defer></script><script src="/blog/assets/js/2.475e6591.js" defer></script><script src="/blog/assets/js/19.ff66857f.js" defer></script>
  </body>
</html>
